# Michael Castellano
# EENG 350
# Demo 1
# Marker detection and angle calculation

from picamera.array import PiRGBArray
from picamera import PiCamera
from time import sleep
from PIL import Image
from cv2 import aruco
import time
import numpy as np
import argparse
import cv2
import PIL
import math
import serial
import time
import board
import busio
import smbus
import adafruit_character_lcd.character_lcd_rgb_i2c as character_lcd


# Initialise I2C bus.
i2c = busio.I2C(board.SCL, board.SDA)

# Initialize
bus = smbus.SMBus(1)

# Set up the LCD screen
lcd_columns = 16
lcd_rows = 2

# Initialise the LCD class
lcd = character_lcd.Character_LCD_RGB_I2C(i2c, lcd_columns, lcd_rows)
lcd.clear()
lcd.color = [100, 100, 100] # White screen

# Gloval Variables
global quadrant, aruco_dict, parameters, frame, corners, ids, rejectedImgPoints, frame_markers, angle
# Turn on video
video = cv2.VideoCapture(0)

# Function to write one byte of a string to the Arduino
def writeNumber(value):
    bus.write_byte(0x20, value) # Address of Arduino (slave) is 0x10
    return -1
        
def aruco_location():
    fov = .12 *1200*4.5 #3.05mm but in inches
    real_distance = 6.0 # 5.5 inch
    x_distance = (corners[0][0][1][0]- corners[0][0][0][0]) ** 2
    y_distance = (corners[0][0][1][1] - corners[0][0][0][1]) ** 2
    image_distance = corners[0][0][1][0] - corners[0][0][0][0]
    distance = (fov * real_distance / image_distance) # In inches
    distance = distance - ( distance - 12 ) / 12
    print(distance)
    writeNumber(int(distance))
    reference1 = math.sqrt((corners[0][0][3][0] - corners[0][0][0][0])**2 +
                           (corners[0][0][3][1] - corners[0][0][0][1])**2) + corners[0][0][0][0]
                           
    reference2 = math.sqrt((corners[0][0][2][0] - corners[0][0][1][0])**2 +
                           (corners[0][0][2][1] - corners[0][0][1][1])**2) + corners[0][0][2][0]
                           
    imageCenter = (reference1 / 2) + (reference2 / 2) / 2
    # Calculate center of marker based on four corners
    x_cord = ((((corners[0][0][1][0] - corners[0][0][0][0])/2)
               + ((corners[0][0][2][0] - corners[0][0][3][0])/2) ) / 2) + corners[0][0][0][0]
    
    x_cord = x_cord - 300
    print(x_cord)
    X = (x_cord * 4.5) /distance

    
    # Measurers angle from [30,0] from left side to right side of view
    angle = math.asin(X)

    print("Center value is: ", x_cord)
    print("Angle is: " , angle)
    print("Distance is : " , distance)
    # Print to LCD screen
    lcd.message = "Angle: %.2f\nDistance: %.2f" %(angle, distance)
    
while True:
    # Get current frame and convert to grayscale. Print frame
    check,frame = video.read()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    cv2.imshow("Capturing", frame)
    
    # Checks for aruco marker
    aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)
    parameters = aruco.DetectorParameters_create()
    corners, ids, rejectedImgPoints = aruco.detectMarkers(gray, aruco_dict, parameters = parameters)
    frame_markers = aruco.drawDetectedMarkers(frame, corners, ids)
    if ids != None :   
        cv2.imshow("Capturing",frame_markers)
        aruco_location()
        break
    else:
        angle = 0
        distance = 0

# Stop recoring if 'q' is pressed
    key = cv2.waitKey(1)
    if key == ord('q'):
        break
    
# Stop video and close all windows
video.release()
cv2.destroyAllWindows()


